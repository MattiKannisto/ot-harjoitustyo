# Architecture of the application
## Overall structure

The program has following structure depicted as a package diagram:

![image](https://github.com/MattiKannisto/ot-harjoitustyo/raw/master/dokumentaatio/kuvat/package_diagram.png)

User interface (UI) of the application is stored in the package 'ui'. UI uses services that are stored in 'services' package. Services use entities and repositories used to store the information of the entities which are stored in packages 'entities' and 'repositories', respectively.

## User interface

The application has a graphical user interface which consists of five views. One of the views (ui.py) is constantly displayed when the application is run and this class activates or inactivates the other views as required. The constant view consist of options menu and instruction area. In the former, the user can ask for help or exit the application, and when he/she has logged in, also change settings and log out from the application. The latter will display instructions when the user tries to do something he/she is not allowed to do (e.g. try to create an account with invalid username) and also show help when selected by the user from the options menu.

The four variable views are:
  - Log in view (login_view.py)
  - Create account view (create_account_view.py)
  - Settings view (settings_view.py)
  - Main view for using the applications (main_view.py)

Constant view of the application (ui.py) constantly checks the internal state of its account service object and based on this information activates or inactivates the variable views. For example, if the logged_in_user and creating_new_account variables of the account service object are None and False, respectively, the constant view activates log in view and inactivates all other views. All variable views are given the account service object as their parameters (main view also is given the options menu since if adds additional items to it). The main view also creates instances of the primer service, DNA fragment service and protein services classes. This way as much as possible of the application logic is handled by the service classes, as the user interface classes do not need to directly interact with repositories or entities.

## Application logic

Logic of the application is contained mostly in service classes of the application. They interact with entities and repositories, which do not directly interact with each other. Methods of the service classes do not take entity objects as their parameters, but instead take string, integer and float values kept in the state of each entity. Services also give these values, instead of the entity objects to the repository methods. This was done to reduce dependencies between different classes of the application. Independency of each class from other classes could have been improved by creating methods for example for getting the name of the logged in user from account service. Currently this is achieved by accessing the logged in user Account object and its 'name' variable, so the user interface classes need to know how the Account class has been implemented. By creating e.g. get_logged_in_user_name() function, the user interface could have been more ignorant to how the Account class has been implemented.

The application has three entities, Account, DnaFragment and Primer [Account, DnaFragment and Primer](https://github.com/MattiKannisto/ot-harjoitustyo/raw/master/dokumentaatio/kuvat/entities.png). Each created account can have multiple DnaFragments and each DnaFragment can have multiple primers designed for it. The SQLite database does not store dependencies between these data using jointables but the DNA fragment table instead has a column for owner name, which links each row to a particular account (owner name of DNA fragment is the name of the account that has added it to the database). The primers are linked similarly to the DNA fragments which act as their template DNAs.


The service objects create new account, primer and DNA fragment objects based on function calls from the user interface and store this information in the database using the repository objects, retrieve information regarding these entities from the database, and/or write this information to .xlsx or .csv files to the working directory of the user.

## Permanent storage of information

Interaction with the SQL database is carried out using the repository classes of the application. Account, DNA fragment and primer information is both saved to and retrieved from the database. Primer information and protein information is also stored to .xlsx and .csv files by the PrimerService and ProteinService classes, respectively. This information is never retrieved from these files but is only written to them.

Protein information is not permanently stored and thus there is no protein repository in the application. Since all information regarding the protein is its amino acid sequence as a string, there is no entity class for proteins. The sole reason for protein service in the application is to translate forward strands of the DNA fragments into protein (i.e. amino acid) sequences. This allows the user to see how different variants of a DNA fragment affect the corresponding protein sequence. Also, if the application will be extended to analysis of DNA sequencing results, the translation functionality will be highly useful as the effects of mutations can be calculated (e.g. does a mutation change amino acid sequence of the protein).

## Functionalities

### Help and instructions
The application gives the user help when the user selects 'Help' from the options menu and instructions when the user tries to do something that he/she is not allowed to do. These will be displayed in the notification area of the constant view of the UI. Furthermore, the user can enter help mode in the main view of the application. This will change functionality of each button and options menu item so that instead of doing their normal functionalities, information how to use these buttons and options menu items is displayed in the output area of the main view. The output area also show in the normal mode information on the successfulness of differen DNA fragment addition and analysis actions carried out by the user. The text and color of these notifications is given either by the service classes (for DNA fragment addition and analysis actions) or the variable views of the UI (for help and instructions on using the UI). The help and notifications are displayed in the constant view's notification area by recursively going through the list of notifications and re-configuring the instructions label of the instructions area by changing the text and color of the text. The same logic applies to the output area of the main view but this is done immediately, while the instructions area of the constant view is updated only after certain amount of time has passed. The help and instructions was implemented in this fashion since it was considered more user friendly to limit the instructions/help area in the views other than the main view. For the main view the output area was considered more convenient since the user might carry out multiple actions on each DNA fragment and it is convenient to see the effects of previous actions. This is important for example if the user attempts generating more primers for a given DNA fragment by adjusting the sequencing primer settings in the options menu item 'Settings'.

### Adding a DNA fragment

When the user inserts a name and a sequence for the new DNA fragment and clicks 'Add new DNA fragment' button, following sequence of actions are carried out:

![image](https://github.com/MattiKannisto/ot-harjoitustyo/blob/master/dokumentaatio/kuvat/add_dna_fragment_sequence_chart.png)

When the user clicks a button for adding a new DNA fragment, the MainView calls an DnaFragmentService function for attempting to create a new DNA fragment. DNA fragment name and sequence, which have been entered by the user in the text entries of MainView, and the logged in user's user name (i.e. DNA fragment owner name) are given as arguments to this function. The DnaFragmentService function will call several of its own functions to test validity of the DNA fragment and whether it can be added to the database (it cannot if another DNA fragment in database has the same name for example). If the DNA fragment cannot be added to the database, the function will return a notification of this. However, if the DNA fragment can be added, as is the case in the chart above, DnaFragmentService calls a DnaFragmentRepository function for adding the DNA fragment to the database. After this, the DnaFragmentService function returns a notification that the action was successful to the MainView. MainView will call its own function to add the notification to the notification area and thus the user will be notified that the action was successful. After this, the MainView will add the newly added DNA fragment to the dropdown list where the names of the DNA fragments that the user has already added are shown. This is done so that the MainView calls its own function for _add_users_dna_fragments_dropdown_list() which will then request all DNA fragments of the user from the DnaFragmentService by calling its function and giving the name of the logged in user as an argument. DnaFragmentService requests then this information from the DnaFragmentRepository by calling the repository's function and passing the name of the account of which DNA fragments are to be fetched from the database as an argument. When the DnaFragmentRepository receives this information from the database, it returns them to the DnaFragmentService as a list of tuples. DnaFragmentService then converts this list of tuples into DnaFragmentObjects by calling its own function for this purpose. The list of DnaFragment objects is then returned to the MainView which will set names of the DNA fragments as elements of the dropdown menu. The user will now be able to select the newly added DNA fragment for analysis.

### Translating a DNA fragment sequence into protein sequence

When the user translates a DNA fragment sequence into a protein sequence, following actions take place:

![image](https://github.com/MattiKannisto/ot-harjoitustyo/blob/master/dokumentaatio/kuvat/translation_sequence_chart.png)

Clicking of the 'Translate' button by the user causes the MainView to call its own function _translate() which will then request the DNA fragment the user has selected from the dropdown menu from the DnaFragmentService which will retrieve the information from the DnaFragmentRepository and return it to the MainView as an object. MainView _translate function will then pass DNA fragment's information, together with logged in user's working directory, as arguments to the ProteinService function for attempting to translate the sequence. This function will first test that the directory and forward strand of given to it as arguments are not None and that the user can write to the directory. Then, ProteinService will use its function _translate which will recursively go through the for_strand string and check which codons (three letters in the string) correspond to which amino acids and start and stop the translation based on the presence of the start and stop codons. The generated protein sequence will then be returned to the function that called it which will check that the translation is not None, which would be the case if the _translate function did not encounter a start codon in the forward strand. If the translation is not None, the function will call _write_to_file function and pass to it as arguments logged in user's working directory string, name of the DNA fragment as a string and the translation string. This function will then make the directory if it does not exist, will create the file with a correct name and then write the translation into it. After this, the ProteinService function that the MainView called, will return a notification to the MainView that the translation was successful, MainView will call its _add_notification function giving this notification to its argument, and the notification will be shown to the user in the notification area of the MainView.

### Other functionalities

Creating a user account and generating sequencing primers for a DNA fragment work in similar fashion as adding a DNA fragment. There are small differences in the implementation of these functionalities (e.g. writing primers to .xlsx file) but the main principles are the same.

## Suggestions for improvement

The programming style for views stored in the 'ui' package is not of very high quality. Thus all contents of the 'ui' package should be refactored. The service classes contain some code that is quite similar in all services. One could make another file where the code needed by all service classes (e.g. function for converting tuples retrieved from databases into objects) would be stored. Also, the file writing functions could be moved to a file containing all file related functions.

The instruction area of the constant view shows help when the user selects 'Help' from the options menu. The help string is displayed so that the text appears to move from right to left. The rightmost letter however is not aligned to the rigthmost part of the frame but instead is located in the middle of the frame (depending on the variable view shown) and moves during displaying of the help string. This is caused by the fact that different fonts displayed in the label have different width measured in pixels. This could be fixed by taking the right number of letters from the help string to string that is used to configure the instructions label so that the width of the label in pixels would correspond to the width of the frame.

The application displays notifications to the user in different UI views. This is implemented by giving the constant view a list of two element lists, where first element is instruction string and the second element the instruction color as a string, from service classes. The information in each item of these lists is then used to configure the instructions label so that each instruction is displayed for a certain amount of time. Since these instructions are give to the constant view of the UI by multiple classes, it might be better to create a class for the instructions instead of using the lists of two element lists.

The notifications in the instructions label in the constant view of the UI are displayed with different speed depending on the type of the notification. The instructions if the user has carried out something that is not allowed (e.g. entered invalid information to the log in screen), the notifications are displayed for 2 seconds at a time. However, when the user selects 'Help' from the options menu, the notifications label is updated after every 0.1 seconds so that the help string moves at sufficient speed across the label. Otherwise, the notification label is updated after every 0.01 seconds so that the default instruction of each variable view is not displayed still when the user for example moves from log in view to create user account view. However, if the user changes the view when the help string is still being displayed, or when the instructions that are displayed 2 secods at a time are being shown, the default instruction of that view is not shown until the aforementioned instructions have been displayed. One could improve the notification area by making it show the default instruction of each variable view immediately when the user changes the view. This would improve usability of the application as the user most likely does not want to see instructions how to log in when he/she is already in the create user account view.

If a user has not added any DNA fragments yet, the main view shows, instead of the dropdown menu for the existing DNA fragments, a dropdown menu where the only item is 'None'. This was done to prevent the application from crashing but the 'None' dropdown menu is not removed from the main view grid when a DNA fragment is added, but is rather hidden beneath the new dropdown menu. If the added DNA fragment has short name, the 'None' dropdown menu is still visible and the user can click it. Clicking the 'None' dropdown menu does not cause any actions to be carried out but reduces the visual pleasentness of the application.

The SQLite database uses DnaFragment name as a primary key. This is not a very good practise as different users might want to add DNA fragments with same name. Current version of the application prevents different users from adding DNA fragments with the same name which solves the problem but it would be better to allow using same names and having for example row id as the primary key. Also, it would be beneficial if the would search the database when the user is adding a new DNA fragment to see if there is already a fragment with same sequence. If a fragment with same sequence has been analyzed before, it is likely that the sequencing primers are already available in the laboratory and there is no need to re-design them.
