# Architecture of the application
## Overall structure

The program has following structure depicted as a package diagram:
![image](https://github.com/MattiKannisto/ot-harjoitustyo/blob/master/dokumentaatio/kuvat/package_diagram.png)

User interface (UI) of the application is stored in the package 'ui'. GUI uses services that are stored in 'services' package. Services use entities and repositories used to store the information of the entities which are stored in packages 'entities' and 'repositories', respectively.

## User interface

The application has a graphical user interface which consists of five views. One of the views (ui.py) is constantly displayed when the application is run and this class activates or inactivates the other views as required. The constant view consist of options menu and instruction area. In the former, the user can ask for help or exit the application, and when he/she has logged in, also change settings and log out from the application. The latter will display instructions when the user tries to do something he/she is not allowed to do (e.g. try to create an account with invalid username) and also show help when selected by the user from the options menu.

The four variable views are:
  - Log in view (login_view.py)
  - Create account view (create_account_view.py)
  - Settings view (settings_view.py)
  - Main view for using the applications (main_view.py)

Constant view of the application (ui.py) constantly checks the internal state of its account service object and based on this information activates or inactivates the variable views. For example, if the logged_in_user and creating_new_account variables of the account service object are None and False, respectively, the constant view activates log in view and inactivates all other views. All variable views are given the account service object as their parameters (main view also is given the options menu since if adds additional items to it). The main view also creates instances of the primer service, DNA fragment service and protein services classes. This way as much as possible of the application logic is handled by the service classes, as the user interface classes do not need to directly interact with repositories or entities.

## Application logic

Logic of the application is contained mostly in service classes of the application. They interact with entities and repositories, which do not directly interact with each other. Methods of the service classes do not take entity objects as their parameters, but instead take string, integer and float values kept in the state of each entity. Services also give these values, instead of the entity objects to the repository methods. This was done to reduce dependencies between different classes of the application. Independency of each class from other classes could have been improved by creating methods for example for getting the name of the logged in user from account service. Currently this is achieved by accessing the logged in user Account object and its 'name' variable, so the user interface classes need to know how the Account class has been implemented. By creating e.g. get_logged_in_user_name() function, the user interface could have been more ignorant to how the Account class has been implemented.

The service objects create new account, primer and DNA fragment objects based on function calls from the user interface and store this information in the database using the repository objects, retrieve information regarding these entities from the database, and/or write this information to .xlsx or .csv files to the working directory of the user.

## Permanent storage of information

Interaction with the SQL database is carried out using the repository classes of the application. Account, DNA fragment and primer information is both saved to and retrieved from the database. Primer information and protein information is also stored to .xlsx and .csv files by the PrimerService and ProteinService classes, respectively. This information is never retrieved from these files but is only written to them.

Protein information is not permanently stored and thus there is no protein repository in the application. Since all information regarding the protein is its amino acid sequence as a string, there is no entity class for proteins. The sole reason for protein service in the application is to translate forward strands of the DNA fragments into protein (i.e. amino acid) sequences. This allows the user to see how different variants of a DNA fragment affect the corresponding protein sequence. Also, if the application will be extended to analysis of DNA sequencing results, the translation functionality will be highly useful as the effects of mutations can be calculated (e.g. does a mutation change amino acid sequence of the protein).

## Functionalities

## Help and instructions
The application gives the user help when the user selects 'Help' from the options menu and instructions when the user tries to do something that he/she is not allowed to do. These will be displayed in the notification area of the constant view of the UI. Furthermore, the user can enter help mode in the main view of the application. This will change functionality of each button and options menu item so that instead of doing their normal functionalities, information how to use these buttons and options menu items is displayed in the output area of the main view. The output area also show in the normal mode information on the successfulness of differen DNA fragment addition and analysis actions carried out by the user. The text and color of these notifications is given either by the service classes (for DNA fragment addition and analysis actions) or the variable views of the UI (for help and instructions on using the UI). The help and notifications are displayed in the constant view's notification area by recursively going through the list of notifications and re-configuring the instructions label of the instructions area by changing the text and color of the text. The same logic applies to the output area of the main view but this is done immediately, while the instructions area of the constant view is updated only after certain amount of time has passed. The help and instructions was implemented in this fashion since it was considered more user friendly to limit the instructions/help area in the views other than the main view. For the main view the output area was considered more convenient since the user might carry out multiple actions on each DNA fragment and it is convenient to see the effects of previous actions. This is important for example if the user attempts generating more primers for a given DNA fragment by adjusting the sequencing primer settings in the options menu item 'Settings'.

When the user inserts a name and a sequence for the new DNA fragment and clicks 'Add new DNA fragment' button, following sequence of actions are carried out:
![image](https://github.com/MattiKannisto/ot-harjoitustyo/blob/master/dokumentaatio/sequence_chart.png)
The event handler for the button 'Add new DNA fragment' calls function 'try_to_create_new_dna_fragment_and_return_notification()' of DnaFragmentService with the parameters 'name' and 'sequence' that user had previously written in the text entries. The button is enabled only when these entries are not empty. DnaFragmentService then calls function 'find_by_name()' of DnaFragmentRepository with 'name' as a parameter. If a DNA fragment with that name is not found, a 'None' is returned. In such a case, DnaFragmentService calls its own function 'incorrect.letters.found' with 'sequence' as a parameter. If the DNA sequence contains only allowed letters ('A', 'T', 'C', 'G'), a booelan 'False' is returned and DnaFragmentService calls DnaFragmentRepository's function create() with 'name' and 'sequence' as parameters. DnaFragmentRepository then saves a new DNA fragment in the MySQL database using the given parameters. After this, DnaFragmentService returns a list of two elements (a notification text and a color or the notification text as strings) to the UI. UI uses this list to update its list of notifications by calling its own function add_notification() using the list returned by DnaFragmentService as a parameter. UI then calls its own function add_users_dna_fragments_dropdown_list(), which calls DnaFragmentService's function 'get_all_dna_fragments()' function which then calls DnaFragmentRepository's function 'find_all()' which is used to retrieve all DNA fragments from the database. This list of DNA fragments is then returned first to DnaFragmentService and then to UI, which uses it to update a dropdown list containing all DNA fragments of the user. Finally UI calls its own function 'update_notification_area()' after which the user is shown a notification that a new DNA fragment has been added. Since adding new DNA fragment was successful, the notification will be shown in green color.

## Suggestions for improvement

The programming style for views stored in the 'ui' package is not of very high quality. Thus all contents of the 'ui' package should be refactored. The service classes contain some code that is quite similar in all services. One could make another file where the code needed by all service classes (e.g. function for converting tuples retrieved from databases into objects) would be stored. Also, the file writing functions could be moved to a file containing all file related functions. The instruction area of the constant view shows help when the user selects 'Help' from the options menu. The help string is displayed so that the text appears to move from right to left. The rightmost letter however is not aligned to the rigthmost part of the frame but instead is located in the middle of the frame (depending on the variable view shown) and moves during displaying of the help string. This is caused by the fact that different fonts displayed in the label have different width measured in pixels. This could be fixed by taking the right number of letters from the help string to string that is used to configure the instructions label so that the width of the label in pixels would correspond to the width of the frame.

The application displays notifications to the user in different UI views. This is implemented by giving the constant view a list of two element lists, where first element is instruction string and the second element the instruction color as a string, from service classes. The information in each item of these lists is then used to configure the instructions label so that each instruction is displayed for a certain amount of time. Since these instructions are give to the constant view of the UI by multiple classes, it might be better to create a class for the instructions instead of using the lists of two element lists.

The notifications in the instructions label in the constant view of the UI are displayed with different speed depending on the type of the notification. The instructions if the user has carried out something that is not allowed (e.g. entered invalid information to the log in screen), the notifications are displayed for 2 seconds at a time. However, when the user selects 'Help' from the options menu, the notifications label is updated after every 0.1 seconds so that the help string moves at sufficient speed across the label. Otherwise, the notification label is updated after every 0.01 seconds so that the default instruction of each variable view is not displayed still when the user for example moves from log in view to create user account view. However, if the user changes the view when the help string is still being displayed, or when the instructions that are displayed 2 secods at a time are being shown, the default instruction of that view is not shown until the aforementioned instructions have been displayed. One could improve the notification area by making it show the default instruction of each variable view immediately when the user changes the view. This would improve usability of the application as the user most likely does not want to see instructions how to log in when he/she is already in the create user account view.